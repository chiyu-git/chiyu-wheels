# 图

## 概述

- 图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为任何二元关系都可以用图来表示。 

- 任何社交网络，例如Facebook、Twitter和Google plus，都可以用图来表示。 

- 图就是一组节点，以网络的形式互相连接。节点也被称为**顶点**（vertices）。一对（v,u）就叫做一个**边**，表示顶点 v 和顶点 u 相连。一个边可能包含**权重/成本**，显示从顶点 v 到 u 所需的成本。

  > 常用小写字母v和u代表一对相连的顶点，（v,u）代表连接他们的边

- 我们还可以使用图来表示道路、航班以及通信状态，如下图所示： 


- 一个图G = (V, E)由以下元素组成：

  - V：一组顶点 
  - E：一组边，连接V中的顶点 

- 下图表示一个图： 


- 由一条边连接在一起的顶点称为**相邻顶点**。比如，A和B是相邻的，A和D是相邻的，A和C是相邻的，A和E不是相邻的。 

- 一个顶点的**度**是其相邻顶点的数量。比如：

  - A和其他三个顶点相连接，因此，A的度为3；
  - E和其他两个顶点相连，因此，E的度为2。 

- **路径**是顶点v1,  v2,…,vk的一个**连续序列**，其中vi和vi+1是相邻的。以上一示意图中的图为例，其中包含路径A B E I和A C D G。 

- 简单路径要求**不包含重复**的顶点。举个例子，A D G是一条简单路径

- **环**也是一个简单路径，称为**简单闭路径**，比如A D C A（最后一个顶点重新回到A）

- 如果图中不存在环，则称该图是**无环的**。如果图中每两个顶点间都存在路径，则该图是**连通的**

## 有向图和无向图 

- 图可以是无向的（边没有方向）或是有向的（有向图）。如下图所示，有向图的边有一个方向： 


- 如果图中每两个顶点间在**双向**上都存在路径，则该图是**强连通**的。例如，C和D是强连通的，
  而A和B不是强连通的。 

- 有向图中：**前溯点和后继点**   @@@

  > predecessor  successor

- 无向图中：**前溯点和邻居结点**   @@@

  > predecessor  neighbour

- 图还可以是未加权的（目前为止我们看到的图都是未加权的）或是**加权**的。如下图所示，加权图的边被赋予了权值： 


- 我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径，以及环检测。

## 图的表示

- 从数据结构的角度来说，我们有多种方式来表示图。在所有的表示法中，不存在绝对正确的方式。图的正确表示法取决于待解决的问题和图的类型。

### 邻接矩阵

- 图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为`i`的节点和索引为`j`的节点相邻，则`array[i][j] === 1，否则array[i][j] === 0`，


**缺点**

- 不是**强连通**的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。

  > 例如，找给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。

- 邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，而2维数组不太灵活。 

### 邻接表 

- 我们也可以使用一种叫作邻接表（adjacency List）的**动态数据结构**来表示图。邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。


- 在邻接表中，顶点用键名来表示，边通过键名对应的字典中的元素来表示

### 对比

- 尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有着不同的性质

#### 邻接矩阵

- 要找出顶点v和w是否相邻，使用邻接矩阵会比较快

### 关联矩阵 

- 我们还可以用关联矩阵来表示图。在关联矩阵中，**矩阵的行表示顶点，列表示边**。如下图所示，我们使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则`array[v][e] === 1；否则，array[v][e] === 0`。 


- 关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。

## 图的实现

### Graph类骨架

- ```js
  function Graph() { 
    const vertices = []; //{1} 
    const adjList = new Dictionary(); //{2} 
  } 
  ```

- 我们使用一个数组来存储图中所有顶点的名字（行{1}），以及一个字典（在第7章中已经实现）来存储**邻接表**（行{2}）。字典将会使用顶点的名字作为键，邻接顶点列表作为值。vertices数组和adjList字典两者都是我们Graph类的私有属性。 

### addVertex()

- ```js
  this.addVertex = function(v){ 
    vertices.push(v); //{3} 
    adjList.set(v, []); //{4} 
  }; 
  ```

- 这个方法接受顶点v作为参数。我们将该顶点添加到顶点列表中（行{3}），并且在邻接表中，设置顶点v作为键对应的字典值为一个空数组（行{4}）

### addEdge()

- ```js
  this.addEdge = function(v, u){
    // 添加从v到u的边 
    adjList.get(v).push(u) //{5} 
    // 添加从u到v的边 
    adjList.get(u).push(v) //{6} 
  }
  ```

- 这个方法接受两个顶点作为参数。首先，通过将u加入到v的邻接表中，我们添加了一条自顶点v到顶点u的边。

- 如果你想实现一个有向图，则行{5}就足够了。由于本章中大多数的例子都是基于无向图的，我们需要添加一条自u向v的边（行{6}）。

- 实现有向图和无向图，只有这个方法有区别 @@@

- 加权图如何实现呢？@@@ 添加边的同时添加权值

  ```js
  this.addEdge = function(v, u,w){
    // 添加从v到u的边 
    adjList.get(v).push([u,w]) //{5} 
    // 添加从u到v的边 
    adjList.get(u).push([v,w]) //{6} 
  }
  ```

### toString()

- ```js
  this.toString = function(){ 
    let s = ''
    for (let i=0; i<vertices.length; i++){ //{10} 
      s += vertices[i] + ' -> ' 
      // 遍历该顶点的邻接表
      const neighbors = adjList.get(vertices[i]) //{11} 
      for (let j=0; j<neighbors.length; j++){ //{12} 
        s += neighbors[j] + ' ' 
      } 
      s += '\n' //{13} 
    } 
    return s  
  }
  ```

- 我们为邻接表表示法构建了一个字符串。首先，迭代vertices数组列表（行{10}），将顶点的名字加入字符串中。接着，取得该顶点的邻接表（行{11}），同样也迭代该邻接表（行{12}），将相邻顶点加入我们的字符串。邻接表迭代完成后，给我们的字符串添加一个换行符（行{13}），这样就可以在控制台看到一个漂亮的输出了。运行如下代码：

  ```js
  var graph = new Graph(); 
  var myVertices = ['A','B','C','D','E','F','G','H','I']; //{7} 
  for (var i=0; i<myVertices.length; i++){ //{8} 
    graph.addVertex(myVertices[i]); 
  } 
  
  graph.addEdge('A', 'B'); //{9} 
  graph.addEdge('A', 'C'); 
  graph.addEdge('A', 'D'); 
  graph.addEdge('C', 'D'); 
  graph.addEdge('C', 'G'); 
  graph.addEdge('D', 'G'); 
  graph.addEdge('D', 'H'); 
  graph.addEdge('B', 'E'); 
  graph.addEdge('B', 'F'); 
  graph.addEdge('E', 'I'); 
  
  graph.toString()
  ```


## 图的遍历

- 和树数据结构类似，我们可以访问图的所有节点。有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search，BFS）和深度优先搜索（Depth-First Search，DFS）。
- 图遍历可以用来**寻找**特定的**顶点**或寻找两个顶点之间的**路径**，检查图是否连通，检查图是否含有环等。
- 图遍历算法的思想是必须**追踪每个第一次访问的节点**，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出**第一个被访问的顶点**。 
- 完全探索一个顶点要求我们查看该顶点的**每一条边**。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进**待访问顶点列表**中。
- 为了保证算法的效率，务必**访问每个顶点至多两次**。连通图中每条边和顶点都会被访问到。 
- 广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是**待访问顶点列表的数据结构**。 

|   算   法    | 数据结构 | 描   述                                                      |
| :----------: | :------: | ------------------------------------------------------------ |
| 广度优先搜索 |   队列   | 通过将顶点存入队列中，最先入队列的顶点先被探索               |
| 深度优先搜索 |    栈    | 通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |

- 当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。 
  - 白色：表示该顶点还没有被访问。 
  - 灰色：表示该顶点被访问过，但并未被探索过。 
  - 黑色：表示该顶点被访问过且被完全探索过。 
  - 这就是之前提到的务必访问每个顶点最多两次的原因。 

### 广度优先搜索

#### 实现

- 广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点


- 以下是从顶点v开始的广度优先搜索算法所遵循的步骤：

  1. 创建一个队列Q。 
  2. 将v标注为被发现的（灰色），并将v入队列Q。 
  3. 如果Q非空，则运行以下步骤： 
     1. 将u从Q中出队列； 
     2. 将标注u为被发现的（灰色）； 
     3. 将u所有未被访问过的邻点（白色）入队列； 
     4. 将u标注为已被探索的（黑色）。 

- ```js
  this.bfs = function(v, callback){ 
    const color = initializeColor(),  //{2} 
          queue = new Queue()         //{3}
          // 入队作为遍历的起点 
          queue.enqueue(v)            //{4} 
    // 如果队列非空
    while (!queue.isEmpty()){       //{5}
      // 从队列弹出一个顶点
      let v = queue.dequeue()
      // 获取该顶点的邻接表
      neighbors = adjList.get(v)
      color[v] = 'grey'                      // {8} 
      // 将所有未被探索的邻居加入队列
      for (let i=0; i<neighbors.length; i++){ 
        let u = neighbors[i]
        if (color[u] === 'white'){
          color[u] = 'grey'
          queue.enqueue(u)
        } 
      } 
      color[v] = 'black' // {14} 
      if (callback) {     
        callback(v) 
      } 
    } 
  }
  ```

  ```js
  function initializeColor(){ 
    const color = [] 
    for (let i=0; i<vertices.length; i++){ 
      color[vertices[i]] = 'white' //{1} 
    } 
    return color 
  }
  ```

- 广度优先搜索和深度优先搜索都需要标注被访问过的顶点。为此，我们将使用一个辅助数组color。由于当算法开始执行时，所有的顶点颜色都是白色（行{1}），所以我们可以创建一个辅助函数initializeColor，为这两个算法执行此初始化操作。

- 我们要做的第一件事情是用initializeColor函数来将color数组初始化为white（行{2}）。

- 我们还需要声明和创建一个Queue实例（行{3}），它将会存储待访问和待探索的顶点。 

- 照着本章开头解释过的步骤，bfs方法接受一个顶点作为算法的**起始点**。起始顶点是必要的，我们将此顶点入队列（行{4}）。 

- 如果队列非空，我们将通过出队列操作从队列中移除一个顶点，并取得一个包含其所有邻点的邻接表。该顶点将被标注为grey（行{8}），表示我们发现了它（但还未完成对其的探索）。 

- 对于vertex（行{9}）的每个邻点，我们取得其值（该顶点的名字——行{10}），如果它还未被访问过（颜色为white——行{11}），则将其标注为我们已经发现了它（颜色设置为grey——行{12}），并将这个顶点加入队列中（行{13}），这样当其从队列中出列的时候，我们可以完成对其的探索。 

- 当完成探索该顶点和其相邻顶点后，我们将该顶点标注为已探索过的（颜色设置为black——行{14}）。

- 我们实现的这个bfs方法也接受一个回调（我们在第8章中遍历树时使用了一个相似的方法）。这个参数是可选的，如果我们传递了回调函数（行{15}），会用到它。 

- ```js
  function printNode(value){ //{16} 
    console.log('Visited vertex: ' + value); //{17} 
  } 
  graph.bfs(myVertices[0], printNode); //{18} 
  ```

- 首先，我们声明了一个回调函数（行{16}），它仅仅在浏览器控制台上输出已经被完全探索过的顶点的名字。接着，我们会调用bfs方法，给它传递第一个顶点（A——从本章开头声明的myVertices数组）和回调函数。


### 深度优先搜索

#### 实现

- 深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点，


- 深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点v未访问，则访问该顶点v。 

- 要访问顶点v，照如下步骤做：

  - 标注v为被发现的（灰色）。
  - 对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色）。 

- 如你所见，深度优先搜索的步骤是**递归**的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）

- 让我们来实现一下深度优先算法： 

  ```js
  this.dfs = function(callback){ 
    const color = initializeColor() //{1} 
  
    for (let i=0; i<vertices.length; i++){ //{2} 
      if (color[vertices[i]] === 'white'){ //{3} 
        dfsVisit(vertices[i], color, callback); //{4} 
      } 
    } 
  } 
  
  function dfsVisit (v, color, callback){ 
    color[v] = 'grey' //{5} 
    if (callback) callback(v) 
  
    const neighbors = adjList.get(v)         //{7} 
    for (let i=0; i<neighbors.length; i++){ //{8} 
      const u = neighbors[i]               //{9} 
      if (color[u] === 'white'){          //{10} 
        dfsVisit(u, color, callback)   //{11} 
      } 
    } 
    color[v] = 'black' //{12} 
  } 
  ```

  > 此处的callback仅是表意作用，因为很多时候不仅仅需要v，也需要其他信息，更多的情况下需要在不同的地方增加代码，以深度遍历的形式完成任务，比如拓扑排序

- 首先，我们创建颜色数组（行{1}），并用值white为图中的每个顶点对其做初始化，广度优先搜索也这么做的。

- 接着，对于图实例中每一个未被访问过的顶点，我们调用私有的递归函数dfsVisit，传递的参数为顶点、颜色数组以及回调函数。 

- 当访问一个顶点时，我们标注其为被发现的（grey——行{5}）。如果有callback函数的话（行{6}），则执行该函数输出已访问过的顶点。

- 接下来一步是取得包含顶点u所有邻点的列表（行{7}）。对于顶点u的每一个未被访问过（颜色为white——行{10}和行{8}）的邻点w（行{9}），我们将调用dfsVisit函数，传递w和其他参数（行{11}——添加顶点w入调用栈，这样接下来就能访问它）。

- 最后，在该顶点和邻点按深度访问之后，我们回退，意思是该顶点已被完全探索，并将其标注为black（行{12}）。


- 在我们示例所用的图中，行{4}只会被执行一次，因为所有其他的顶点都有路径到第一个调用dfsVisit函数的顶点（顶点A）

## 常问的图面试问题：

- 实现广度优先搜索和深度优先搜索
- 检查一个图是否为树
- 计算一张图中的边的数量
- 找到两个顶点之间的最短路径

# 